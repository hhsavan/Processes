


Signal fundamentals
● Signal blocking, ignoring, handling

- A signal is a notification sent to a process that an event has occurred.

- Think of them as software interrupts. They are similar to hardware
interrupts in the sense that they interrupt the normal flow of execution.

- It is impossible to predict exactly when a signal is going to arrive.


- Hardware Interrupts:

	Hardware interrupts are signals sent by hardware devices to the CPU to indicate that they require attention.

	These interrupts can be triggered by various events, such as a keypress on the keyboard, data arriving on a network interface, or a timer reaching zero.

	When a hardware interrupt occurs, the CPU temporarily stops executing the current program and transfers control to a specific interrupt handler routine, which is a piece of code responsible for handling the interrupt.

	Examples of hardware interrupts include keyboard interrupts, mouse interrupts, timer interrupts, disk I/O interrupts, etc.


- Software Interrupts:

	Software interrupts, also known as "software traps" or "exceptions," are interrupts that are generated by software rather than hardware.

	These interrupts are typically used by the operating system or applications to request specific services from the CPU or to signal exceptional conditions.

	Software interrupts are usually triggered by executing a special instruction (e.g., INT in x86 assembly language) or by attempting to execute privileged or illegal instructions.

	Common uses of software interrupts include system calls (e.g., to request I/O operations or other kernel services), handling division by zero or invalid memory accesses, and implementing multitasking or context switching.

- When a interrupts happened:
	ignore the signal

	handle signal with a custom signal handler
		<Example code implemented>

	Default signal handler

	block and unblock the signal
		<Example code implemented>

- CTRL-C vs CTRL-Z
	ctrl c interrupts the runnning process. (usually ends the program)
	ctrl z suspends the running process. it goes to background. basıldığında bir signal oluşturmadığından 
	custom signal handler'ı yazılamaz
		you can kill with:
			kill <PID>
		you can run it again with:
			fg "%./programExecutable"

- Signals can be sent by the kernel, by other processes, or even by the
user using the kill system call (also available as a shell command):

- Bir signalin generated olup olmadığını kernel kontrol eder. Eğer bir signal oluşturulmuşsa kernel bunu yakalar. 
Daha sonra bu sinyale bir processin register olup olmadığına bakar. eğer bir process bu sinyala register olmuşsa
bu signal bu prıocess'a teslim edilir.

- signal mask:
	When a signal is blocked, it means that the process will not receive that signal until it is unblocked.

- signal pending (signal bekletme)
	If a process receives a signal that it is currently blocking, that signal is
	added to the process’s set of pending signals. When (and if) the signal
	is later unblocked, it is then delivered to the process.


- sigaction:
	signal(<signal>, <function pointer>) fonskiyonu ile aynı işi yapan bir struct ama bu daha iyi bu şekilde kullanılmalı

- waiting for a signal without busy waiting:
	sleep, nanosleep, pause


- is there a way to sleep a process until I wake it up

	Signals:
		Sleep using pause() or sleep() and wake up with a specific signal (e.g., SIGUSR1).
			<code implemented: pause until a user signal generetad>
	Named Pipes (FIFOs):
		Process waits for data on a named pipe and wakes up when data is written.
	Message Queues:
		Process waits for messages on a message queue and wakes up when a message is sent.
	Socket Programming:
		Process waits for data on a socket and wakes up when data is sent to the socket.

- A signal handler should perform the minimum work necessary to
	respond to a signal, and then return control to the main program (or
	terminate the program).
-In most cases, this consists simply of recording the fact that a signal
	occurred. Signals may arrive even while handling them...this is very
	hard to debug.
		Bu durumdan kaçınmak için nelere dikkat edilmeli peki:
			Use async-safe functions in signal handlers. (_exit, write)
			Keep signal handlers short and simple.
			Ensure thread safety with !atomic operations! or synchronization primitives.
			Minimize the use of global state in signal handlers.
			Temporarily block signals during critical sections. (signal mask kullanarak)




● Creating a new process

- system("ls -l") bu fonksiyon konsol komutlarını çalıştırır. consol komutlarıyla ilgili bir hata oluşursa 127,
farklı bir hata ise -1 return eder.
	Pros: it’s simple, error and signal handling are taken care of.
	Cons: a) inefficient since it creates 2 processes, one for the shell, and
		one more more for the commands b) it’s subject to the features,
		limitations, and security flaws of the system’s shell. Since you can’t
		rely on the availability of any particular shell, it’s not portable either.

-fork()
-exec()
	execve, execl ..
	bu bir linux commandını çalıştırır. system fonksiyonundan daha hızlı. ama system kadar güvenli değil.

- Bir child oluşturulduğunda parent processin herşeyi kopyalanır. file discriptorları da tabi ki. bunun üzerinden
aynı dosyaya okuma ve yazma işlemi yapabilirler



● Terminating a process

-bir process 2 şekilde terminate edilir (normal şartlarda)

	- Using the exit Function:
		The executing program calls the exit function explicitly to terminate the process.
		The exit function takes an integer argument, known as the exit code or exit status, which represents the termination status of the process.
		This exit code is typically used to indicate whether the process terminated successfully or encountered an error. A zero exit code conventionally indicates success, while non-zero exit codes typically indicate failure or some specific error condition.
		Example: exit(EXIT_SUCCESS) to indicate successful termination, or exit(EXIT_FAILURE) to indicate failure.

	- Returning from the main Function:
		When the program's main function returns, the process terminates implicitly.
		The return value from the main function serves as the exit code for the process.
		Similar to using the exit function, the exit code returned from main typically indicates the success or failure of the program's execution.
		Conventionally, returning zero from main indicates successful termination, while a non-zero return value indicates failure.
		Example: return 0; to indicate successful termination, or return 1; to indicate failure.

	- More generally, at process termination:
		All open files and streams are closed
		All file locks held by the process are released

- Peki Normal olmayan şartlarda bir process nasıl terminate edilir?
	sinyallerle (SIGKILL etc.)



